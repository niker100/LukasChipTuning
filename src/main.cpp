#include <SPI.h>
// #include <Adafruit_SSD1322.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

#include <ani.hpp>

#define TIME_BETWEEN_ANI_FRAMES 40 

BLEServer *pServer = NULL;
BLECharacteristic *pTimeCharacteristic = NULL;
BLECharacteristic *pStatusCharacteristic = NULL;
bool deviceConnected = false;
bool timeSet = false;
int autoDisconnectTicks = 0;

#define MAX_DELTAS 10
struct Delta
{
  long duration;
  int delta_seconds;
};
Delta deltas[MAX_DELTAS];
int numDeltas = 0;
time_t lastSetTimestamp = 0;

// Used for software SPI
#define OLED_CLK 18
#define OLED_MOSI 23

// Used for software or hardware SPI
#define OLED_CS 5
#define OLED_DC 19

// Used for I2C or SPI
#define OLED_RESET 21
#define OLED_ROTATION 2 // CHANGEME to 0 if your panel is mounted differently

#define SLEEP_PIN 4
#define SLEEP_OVERRIDE_PIN 2

// software SPI
Adafruit_SSD1322 display(256, 64, OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS);
// hardware SPI
// Adafruit_SSD1322 display(256, 64, &SPI, OLED_DC, OLED_RESET, OLED_CS, 1000000);

// 'prneracng', 64x64px
const unsigned char epd_bitmap_prneracng[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe1, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0f, 0x80, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x02, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x04, 0x3f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0c, 0x3f, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x0c, 0x3f, 0x00, 0x02, 0x00,
    0x00, 0x00, 0x0c, 0x0c, 0x7f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0e, 0xff, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x0f, 0xff, 0x1c, 0x00, 0x00, 0x00, 0x02, 0x38, 0x0f, 0xff, 0x1c, 0x00, 0x00,
    0x01, 0x80, 0x38, 0x0f, 0xff, 0xdc, 0x08, 0x00, 0x00, 0x00, 0x38, 0x8f, 0xff, 0xfc, 0x04, 0x00,
    0x00, 0x00, 0x3f, 0x9f, 0xff, 0xfe, 0x02, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfe, 0x42, 0x00,
    0x00, 0x00, 0x1f, 0xff, 0xff, 0xfe, 0x02, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x07, 0xff, 0x07, 0x00,
    0x00, 0x00, 0x1f, 0xd7, 0xfb, 0xff, 0x07, 0x00, 0x00, 0x03, 0x1e, 0xdd, 0x80, 0x3f, 0x8f, 0x00,
    0x00, 0x03, 0x38, 0xa4, 0x00, 0x1f, 0xff, 0x00, 0x02, 0x07, 0x77, 0x58, 0x30, 0xcf, 0xff, 0x00,
    0x01, 0x07, 0x62, 0x80, 0x00, 0x17, 0xff, 0x00, 0x00, 0x0f, 0xdd, 0x71, 0x00, 0x09, 0xff, 0x00,
    0x00, 0x1f, 0xdb, 0xc0, 0x1f, 0xc5, 0xff, 0x00, 0x00, 0x3f, 0xb6, 0x00, 0x60, 0x63, 0xff, 0x00,
    0x00, 0x3f, 0xf5, 0xc0, 0x40, 0x32, 0xfe, 0x00, 0x00, 0x3f, 0x3f, 0x09, 0x88, 0x50, 0x7c, 0x00,
    0x00, 0x3e, 0xc8, 0xc1, 0x64, 0x09, 0xfc, 0x00, 0x00, 0x3e, 0xfb, 0x10, 0x66, 0x08, 0x78, 0x00,
    0x01, 0x3e, 0x72, 0x12, 0x01, 0x00, 0x38, 0x40, 0x01, 0x3e, 0xbc, 0x17, 0x79, 0x14, 0xb8, 0x80,
    0x03, 0x1c, 0xdb, 0x04, 0x44, 0x84, 0xb8, 0x80, 0x03, 0x1d, 0x56, 0x24, 0x87, 0x94, 0xb8, 0x80,
    0x03, 0x0d, 0x80, 0x04, 0xb3, 0x84, 0xb8, 0xc0, 0x07, 0x0d, 0xca, 0x04, 0xb3, 0x94, 0xb8, 0xc0,
    0x07, 0x1d, 0x56, 0x04, 0x87, 0x94, 0xbe, 0xc0, 0x07, 0xfd, 0x16, 0x04, 0x05, 0x1c, 0x7e, 0xe0,
    0x07, 0xfd, 0x00, 0x05, 0x39, 0x18, 0x7e, 0xe0, 0x07, 0xfe, 0x80, 0x06, 0x09, 0x19, 0x7f, 0xe0,
    0x03, 0xfe, 0x00, 0x02, 0x6e, 0x39, 0x7f, 0xe0, 0x01, 0xfe, 0x00, 0x03, 0x0e, 0x70, 0xff, 0xc0,
    0x00, 0xfe, 0x00, 0x01, 0x78, 0x71, 0xff, 0x80, 0x1f, 0xff, 0x00, 0x01, 0xff, 0xe1, 0xff, 0xf8,
    0x0f, 0xff, 0x00, 0x00, 0xc0, 0xe0, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x9e, 0x26, 0xfb, 0xc6, 0x1d, 0x91, 0xc0, 0x07, 0xd9, 0xb6, 0xfb, 0xe7, 0x7d, 0xd7, 0xe0,
    0x06, 0x59, 0xbe, 0x82, 0x67, 0x61, 0xd6, 0x00, 0x07, 0xdf, 0xbe, 0xfb, 0xe9, 0x61, 0xf6, 0xe0,
    0x07, 0x9f, 0x3e, 0x83, 0xcf, 0x61, 0xf6, 0xe0, 0x07, 0x1b, 0xae, 0x82, 0xef, 0x61, 0xb6, 0x60,
    0x06, 0x19, 0xa6, 0xfa, 0x69, 0xbd, 0x93, 0xe0, 0x04, 0x19, 0x26, 0xfa, 0x69, 0x99, 0x91, 0xc0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00,
    0x1f, 0xff, 0xf8, 0x0e, 0x70, 0x1f, 0xff, 0xf8, 0x00, 0x00, 0x1e, 0x71, 0x8e, 0x78, 0x00, 0x00,
    0x00, 0x00, 0x0f, 0x71, 0x8f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x0f, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00};

time_t now;
char strftime_buf[64];
struct tm timeinfo;

#define SERVICE_UUID "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define TIME_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define STATUS_UUID "6841b1b3-3f7b-4b6f-9e0f-2f1b3d1b3b3b"

class ServerCallbacks : public BLEServerCallbacks
{
  void onConnect(BLEServer *pServer)
  {
    deviceConnected = true;
  };

  void onDisconnect(BLEServer *pServer)
  {
    deviceConnected = false;
    pServer->startAdvertising();
  }
};

class Callbacks : public BLECharacteristicCallbacks
{
  void onWrite(BLECharacteristic *pCharacteristic)
  {

    if (pCharacteristic == pTimeCharacteristic)
    {
      std::string value = pCharacteristic->getValue();

      if (value.length() == 0)
      {
        return;
      }

      // Assuming the value is a string with the format "YYYY-MM-DD HH:MM:SS"
      struct tm tm;
      strptime(value.c_str(), "%Y-%m-%d %H:%M:%S", &tm);
      time_t receivedTime = mktime(&tm);

      /*
      // Set the time
      struct timeval now = { .tv_sec = t };
      settimeofday(&now, NULL);
      timeSet = true;
      */

      time_t internalTime;
      time(&internalTime);
      int delta = difftime(receivedTime, internalTime);

      // Set the time
      struct timeval now = {.tv_sec = receivedTime};
      settimeofday(&now, NULL);
      timeSet = true;

      // Ignore too big or small deltas (i.e. more than 1 hour and less than 5 seconds)
      if (abs(delta) > 3600 || abs(delta) < 5)
      {
        return;
      }

      // Store delta
      if (numDeltas <= MAX_DELTAS)
      {
        deltas[numDeltas++] = {receivedTime - lastSetTimestamp, delta};
        numDeltas++;
      }
      else
      {
        // If reached maximum, overwrite oldest delta
        for (int i = 1; i < MAX_DELTAS; i++)
        {
          deltas[i - 1] = deltas[i];
        }
        deltas[MAX_DELTAS - 1] = {receivedTime - lastSetTimestamp, delta};
      }

      lastSetTimestamp = receivedTime;
    }

    std::string data = "Sent data: ";
    data += pCharacteristic->getValue().c_str();
    Serial.println(data.c_str());
    pStatusCharacteristic->setValue(data.c_str());
    pStatusCharacteristic->notify();
  }
};

void setup()
{
  Serial.begin(115200);

  // pinMode(SLEEP_PIN, INPUT_PULLDOWN);
  // pinMode(SLEEP_OVERRIDE_PIN, OUTPUT);
  // digitalWrite(SLEEP_OVERRIDE_PIN, HIGH);

  // while (! Serial) delay(100);
  BLEDevice::init("Geile Socke");
  BLEDevice::setMTU(512);

  // Create the BLE Server
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());

  // Create the BLE Service
  BLEService *pService = pServer->createService(SERVICE_UUID);

  // Create a BLE Characteristic
  pTimeCharacteristic = pService->createCharacteristic(
      TIME_UUID,
      BLECharacteristic::PROPERTY_READ |
          BLECharacteristic::PROPERTY_WRITE);

  pStatusCharacteristic = pService->createCharacteristic(
      STATUS_UUID,
      BLECharacteristic::PROPERTY_READ |
          BLECharacteristic::PROPERTY_WRITE |
          BLECharacteristic::PROPERTY_NOTIFY);

  // Start the service
  pService->start();

  // Start advertising
  pServer->getAdvertising()->start();

  pStatusCharacteristic->setValue("Disconnected");
  pTimeCharacteristic->setCallbacks(new Callbacks());
  pStatusCharacteristic->setCallbacks(new Callbacks());

  if (!display.begin(0x3D))
  {
    Serial.println("Unable to initialize OLED");
    while (1)
      yield();
  }

  Serial.println("SSD1322 initialized");
  // Note: change me if your panel orientation is different than mine
  display.setRotation(OLED_ROTATION);

  Serial.println("SSD1322 clear");
  display.clearDisplay();
  display.display();

  for (auto img : ani_array)
  {
    display.drawBitmap(0, 0, img, 256, 64, SSD1322_WHITE);
    display.display();
    delay(TIME_BETWEEN_ANI_FRAMES);
    display.clearDisplay();
  }

  delay(TIME_BETWEEN_ANI_FRAMES * 3);

  display.drawBitmap(96, 0, epd_bitmap_prneracng, 64, 64, SSD1322_WHITE);
  display.display();
  delay(5000);

  time(&now);
  setenv("TZ", "EST5EDT,M3.2.0/2,M11.1.0", 1);
  tzset();

  // delay(2000);

  // draw a bitmap icon and 'animate' movement
  // testdrawbitmap(logo16_glcd_bmp, LOGO16_GLCD_HEIGHT, LOGO16_GLCD_WIDTH);
}

void loop()
{
  /*
  if(digitalRead(SLEEP_PIN) == !HIGH) {
    Serial.println("Going to sleep");
    display.clearDisplay();
    display.display();
    //esp_sleep_enable_ext0_wakeup((gpio_num_t)SLEEP_PIN, HIGH);
    //esp_deep_sleep_start();
  }
  */

  if (deviceConnected && !timeSet)
  {
    /* connection check now done in react-native App */
    /*
    Serial.println("Device connected");
    pStatusCharacteristic->setValue("ESP connected");
    pStatusCharacteristic->notify();
    */
    autoDisconnectTicks = 0;
  }

  if (!deviceConnected && timeSet)
  {
    Serial.println("Device disconnected");
    timeSet = false;
  }

  if (deviceConnected && timeSet && (autoDisconnectTicks > 500))
  {
    pStatusCharacteristic->setValue("ESP auto-disconnect");
    pStatusCharacteristic->notify();
    pServer->disconnect(pServer->getConnId());
    autoDisconnectTicks = 0;
  }

  time(&now);

  localtime_r(&now, &timeinfo);
  strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1322_WHITE);
  display.setCursor(0, 0);
  display.println(strftime_buf);
  display.display();

  autoDisconnectTicks++;
  delay(10);
}